{"id": "chunk_001", "app_domain": "general", "section": "Data Groups Definition", "type": "definition", "domain": "data_groups", "keywords": ["data group", "data attribute", "object of interest", "definition"], "content": "A Data Group is a distinct, non-empty, non-ordered, non-redundant set of data attributes describing a single object of interest. A Data Attribute is the smallest parcel of information within an identified data group, carrying meaning from the FUR perspective. An Object of Interest is any 'thing' identified from the FUR perspective about which the software is required to process and/or store data. Key Properties: Each data group describes exactly one object of interest, must be distinct (no duplication), cannot be empty, are non-ordered collections, and must be non-redundant."}
{"id": "chunk_002", "app_domain": "real_time", "section": "Data Groups ", "type": "knowledge", "domain": "data_groups", "keywords": ["data groups", "states", "config", "thresholds", "calibration", "COSMIC DG"], "content": "Identify states, configuration parameters, calibration thresholds, and runtime tables used by control logic.\nNature: may be volatile (in-memory buffers) or persistent (configuration), but logically grouped.\nHeuristics: look for state variables (DeviceState), setpoints (TemperatureThresholds), timers/counters"}
{"id": "chunk_102", "app_domain": "real_time", "section": "Examples — Data Groups", "type": "example", "domain": "data_groups", "keywords": ["data groups", "real-time", "signals", "commands"], "content": "Input: On receipt of the Stop signal, the software turns OFF the Heater, turns OFF the Cooking Lamp, and enters a wait state.\nExpected Output:\nObjects of Interest:\n- Stop button: Stop signal\n- Heater: Heater On/Off command\n- Cooking lamp: Cooking lamp On/Off command"}
{"id": "chunk_202", "app_domain": "real_time", "section": "Examples — Data Groups", "type": "example", "domain": "data_groups", "keywords": ["data groups", "real-time", "signals", "settings"], "content": "Input: On receipt of a 30-second signal the software receives the 30-second signal, waits for and receives the elapsed time signal, retrieves the current cooking mode from the RAM, gets a new target temperature for this cooking mode by obtaining it from the relationship stored in the ROM and stores this new target temperature into the RAM.\nExpected Output:\nObjects of Interest:\n- Timer: 30-second signal, Current elapsed time signal\n- Current settings: Current cooking mode, Current target temperature\n- Target settings: New target temperature"}
{"id": "chunk_003", "app_domain": "real_time", "section": "Examples — Data Groups", "type": "example", "domain": "data_groups", "keywords": ["data groups", "real-time", "signals", "commands"], "content": "Input: On receipt of the Start signal, the software sends Turn ON signals to both the Cooking Lamp and the Heater.\nExpected Output:\nObjects of Interest:\n- Start Button: start_signal\n- Cooking Lamp: on_off_command\n- Heater: on_off_command"}
{"id": "chunk_004", "app_domain": "business", "section": "Data Groups ", "type": "knowledge", "domain": "data_groups", "keywords": ["data groups", "entities", "database", "persistence", "COSMIC DG"], "content": "Identify persistent logical entities managed by the application.\nNature: tables/collections and their logical groupings (Customer, Invoice, Product, Order, Payment).\nPersistence: usually stored in a database; stable identifiers and attributes.\nHeuristics: look for core business nouns and records that are created/read/updated/written."}
{"id": "chunk_005", "app_domain": "business", "section": "Examples — Data Groups", "type": "example", "domain": "data_groups", "keywords": ["data groups", "business application", "master data", "validation"], "content": "Input: When a Registrar wishes to enter data about a new Professor, he selects the sub-option 'Add Professor' and enters Professor details including ID, name, address, social security number, Department, qualifications and contact details.\nExpected Output:\nObjects of Interest:\n- Professor: professor_id, name, address, social_security, department, qualifications, contact_details\n- Errors: error_text, validation_message"}
{"id": "chunk_006", "app_domain": "general", "section": "Functional Processes Definition", "type": "definition", "domain": "functional_processes", "keywords": ["functional process", "FUR", "elementary component", "data movements", "definition"], "content": "A Functional Process is an elementary component of FUR comprising a unique, cohesive, independently executable set of data movements. Mandatory Requirements: Must be derived from at least one identifiable FUR, initiated by Entry data movement from functional user, comprise minimum two data movements (always one Entry plus Exit or Write), belong to one and only one layer, and complete when asynchronous timing point is reached per FUR. Characteristics: Elementary (cannot be decomposed further), cohesive (all data movements serve common purpose), independently executable, has a clear triggering event."}
{"id": "chunk_007", "app_domain": "general", "section": "Functional Processes Identification Rules", "type": "rules", "domain": "functional_processes", "keywords": ["process identification", "triggering entry", "cohesion", "independence", "elementary"], "content": "Identification Criteria: Each functional process must have a triggering Entry, be elementary (cannot be decomposed further), be cohesive (all data movements serve common purpose), and be independently executable. Structure Requirements: Minimum 2 data movements (1 Entry + 1 Exit OR 1 Write), no maximum limit (determined by FUR), all movements must relate to the same functional purpose. Validation Rules: Must have identifiable triggering event, produce observable result (Exit or Write), belong to single software layer."}
{"id": "chunk_008", "app_domain": "real_time", "section": "Functional Processes ", "type": "knowledge", "domain": "functional_processes", "keywords": ["functional processes", "control loops", "events", "timers", "interrupts", "COSMIC FP"], "content": "Identify event-driven control processes that respond to signals or timers and complete a control objective.\nTriggers: external interrupts, sensor thresholds, periodic timers, fault events.\nHeuristics: detect→decide→actuate chains; safety, fallback, debounce, hysteresis may be part of the same FP.\nCompletion: when the control action finishes (e.g., actuator commanded and state updated) or a cycle ends."}
{"id": "chunk_208", "app_domain": "real_time", "section": "Examples — Functional Processes", "type": "example", "domain": "functional_processes", "keywords": ["functional process", "real-time", "temperature control", "periodic"], "content": "Input: On receipt of a 5-second signal the software receives the 5-second signal, retrieves the current target temperature from the RAM, retrieves the actual sensor temperature from the Temperature Sensor, sends a Turn ON or OFF command to the Heater.\nExpected Output:\nFunctional Process: Check cooker temperature\nTriggering Event: 5-second signal\nFunctional User: Timer\nTriggering Entry: 5-second signal received"}
{"id": "chunk_108", "app_domain": "real_time", "section": "Examples — Functional Processes", "type": "example", "domain": "functional_processes", "keywords": ["functional process", "real-time", "temperature update", "periodic"], "content": "Input: On receipt of a 30-second signal the software receives the 30-second signal, waits for and receives the elapsed time signal, retrieves the current cooking mode from the RAM, gets a new target temperature for this cooking mode by obtaining it from the relationship stored in the ROM and stores this new target temperature into the RAM.\nExpected Output:\nFunctional Process: Update Target temperature\nTriggering Event: 30-second signal\nFunctional User: Timer\nTriggering Entry: 30-second signal received"}
{"id": "chunk_009", "app_domain": "real_time", "section": "Examples — Functional Processes", "type": "example", "domain": "functional_processes", "keywords": ["functional process", "real-time", "control", "sequence"], "content": "Input: On receipt of the Start signal, the software sends Turn ON signals to both the Cooking Lamp and the Heater.\nExpected Output:\nFunctional Process: Start Cooking\nTriggering Event: Start button pressed\nFunctional User: Start button\nTriggering Entry: Start button pressed"}
{"id": "chunk_010", "app_domain": "business", "section": "Functional Processes ", "type": "knowledge", "domain": "functional_processes", "keywords": ["functional processes", "business transactions", "reporting", "COSMIC FP"], "content": "Identify end-to-end business transactions or reporting processes triggered by a user or system request.\nTriggers: form submissions, API calls, scheduled report requests.\nHeuristics: verbs indicating transaction intent (create, update, validate, approve, query, generate report).\nBoundary: the process is complete when the business goal is achieved (e.g., order placed, report generated)."}
{"id": "chunk_011", "app_domain": "business", "section": "Examples — Functional Processes", "type": "example", "domain": "functional_processes", "keywords": ["functional process", "business application", "CRUD"], "content": "Input: When a Registrar wishes to enter data about a new Professor, he selects the sub-option 'Add Professor' and enters Professor details including ID, name, address, social security number, Department, qualifications and contact details.\nExpected Output:\nFunctional Process: Add a Professor\nTriggering Event: A Registrar needs to add a Professor's details\nFunctional User: Registrar\nTriggering Entry: A Registrar needs to add a Professor's details"}
{"id": "chunk_012", "app_domain": "general", "section": "Functional Users", "type": "definition", "domain": "functional_users", "keywords": ["functional users", "boundary", "external actors", "COSMIC"], "content": "A Functional User is any external entity (human, system, device, or time event) that exchanges data with the software across its boundary.\n\nIdentification Principles:\n- The Functional User must exist outside the software boundary.\n- It can be a sender (provides data to the system), a recipient (receives data from the system), or both.\n- Types include:\n  • Human users: individuals interacting with the software through an interface.\n  • External software systems: other applications or services exchanging data.\n  • Hardware devices: sensors, actuators, controllers...\n  • Time-triggered events: system or clock signals initiating processes.\n"}
{"id": "chunk_013", "app_domain": "real_time", "section": "Functional Users Definition", "type": "knowledge", "domain": "functional_users", "keywords": ["functional users", "sensors", "actuators", "devices", "signals", "COSMIC FU"], "content": "Identify external physical entities (sensors, actuators, devices) or systems exchanging signals with the software.\nIdentification cues: hardware interfaces, signals, interrupts, timers, controllers.\nInclude: entities that emit events/signals to the software (E) or receive control commands/notifications (X).\nExclude: internal tasks/threads unless they represent an external interface.\nTypical phrasing: 'On receipt of <signal>...', 'When <sensor> triggers...', 'Send <command> to <device>'."}
{"id": "chunk_213", "app_domain": "real_time", "section": "Examples — Functional Users", "type": "example", "domain": "functional_users", "keywords": ["functional users", "real-time", "timer", "sensor", "actuator"], "content": "Input: On receipt of a 5-second signal the software receives the 5-second signal, retrieves the current target temperature from the RAM, retrieves the actual sensor temperature from the Temperature Sensor, sends a Turn ON or OFF command to the Heater.\nExpected Output:\nFunctional Users:\n- Timer\n- Temperature Sensor\n- Heater"}
{"id": "chunk_113", "app_domain": "real_time", "section": "Examples — Functional Users", "type": "example", "domain": "functional_users", "keywords": ["functional users", "real-time", "timer", "settings"], "content": "Input: On receipt of a 30-second signal the software receives the 30-second signal, waits for and receives the elapsed time signal, retrieves the current cooking mode from the RAM, gets a new target temperature for this cooking mode by obtaining it from the relationship stored in the ROM and stores this new target temperature into the RAM.\nExpected Output:\nFunctional Users:\n- Timer"}
{"id": "chunk_014", "app_domain": "real_time", "section": "Examples — Functional Users", "type": "example", "domain": "functional_users", "keywords": ["functional users", "real-time", "devices", "sensors", "actuators"], "content": "Input: On receipt of the Start signal, the software sends Turn ON signals to both the Cooking Lamp and the Heater.\nExpected Output:\nFunctional Users:\n- Start button\n- Cooking Lamp\n- Heater"}
{"id": "chunk_015", "app_domain": "business", "section": "Functional Users ", "type": "knowledge", "domain": "functional_users", "keywords": ["functional users", "business", "actors", "external systems", "COSMIC FU"], "content": "Identify external entities that exchange business data with the software.\nIdentification cues: role nouns (Customer, Employee), external systems (ERP, Payment Gateway), API callers.\nInclude: people or systems that SEND data to the app (E) or RECEIVE data from it (X).\nExclude: internal modules, DB engines, schedulers without boundary crossing."}
{"id": "chunk_016", "app_domain": "business", "section": "Examples — Functional Users", "type": "example", "domain": "functional_users", "keywords": ["functional users", "business application", "registrar"], "content": "Input: When a Registrar wishes to enter data about a new Professor, he selects the sub-option 'Add Professor' and enters Professor details including ID, name, address, social security number, Department, qualifications and contact details.\nExpected Output:\nFunctional Users:\n- Registrar"}
{"id": "chunk_017", "app_domain": "general", "section": "Sub Processes Definition", "type": "definition", "domain": "sub_processes", "keywords": ["sub-process", "COSMIC", "internal step", "data movements", "FP step"], "content": "A sub-process is an internal step within a single Functional Process (FP) that groups the minimal, coherent set of elementary data movements (Entry/Exit/Read/Write) required to achieve an intermediate goal (e.g., validate input, retrieve records, store/update data, output response).\n\nScope & cohesion:\n- Exists inside one FP and contributes to its unique functional purpose.\n- Defined by an action-oriented label (e.g., Validate request, Retrieve data, Store update, Produce response).\n- Represents a cohesive and atomic business step — it starts when its preconditions are met and ends when its intermediate result is achieved.\n\nKey COSMIC principles:\n- Each sub-process includes at least one data movement and references exactly one Functional Process.\n- Each data movement manipulates exactly one Data Group.\n- Internal processing (calculations, validations) supports but does not replace data movements"}
{"id": "chunk_018", "app_domain": "real_time", "section": "Sub-Processes & Data Movements ", "type": "knowledge", "domain": "sub_processes", "keywords": ["sub-processes", "E/R/W/X", "signals", "control", "logging", "COSMIC movements"], "content": "Decompose control processes into COSMIC data movements (E, X, R, W) across sensor/controller/actuator boundaries.\nCommon patterns: E(signal reception), R(state or thresholds), X(control command), W(state/log update).\nCyclic behavior: periodic monitor loops (timer-driven) still decompose into E/R/X/W per cycle."}
{"id": "chunk_218", "app_domain": "real_time", "section": "Examples — Sub-Processes", "type": "example", "domain": "sub_processes", "keywords": ["sub-process", "real-time", "entry", "read", "write"], "content": "Input: On receipt of a 30-second signal the software receives the 30-second signal, waits for and receives the elapsed time signal, retrieves the current cooking mode from the RAM, gets a new target temperature for this cooking mode by obtaining it from the relationship stored in the ROM and stores this new target temperature into the RAM.\nExpected Output:\nSub-processes:\n- Sub-process: Receive 30-second signal\n  Functional User: Timer\n  Moved Data Group: 30-second signal\n  Object of Interest: Timer\n  Source: Timer\n  Destination: system\n  Type: Entry\n- Sub-process: Receive Current elapsed time signal\n  Functional User: Timer\n  Moved Data Group: Current elapsed time signal\n  Object of Interest: Timer\n  Source: Timer\n  Destination: system\n  Type: Entry\n- Sub-process: Get cooking mode\n  Functional User: -\n  Moved Data Group: Current cooking mode\n  Object of Interest: Current settings\n  Source: Current settings (RAM)\n  Destination: system\n  Type: Read\n- Sub-process: Get New target temperature for [Current elapsed time + 30 secs.] and Cooking mode\n  Functional User: -\n  Moved Data Group: New target temperature\n  Object of Interest: Target settings\n  Source: Target settings (ROM)\n  Destination: system\n  Type: Read\n- Sub-process: Store the (new) Current target temperature\n  Functional User: -\n  Moved Data Group: Current target temperature\n  Object of Interest: Current settings\n  Source: system\n  Destination: Current settings (RAM)\n  Type: Write"}
{"id": "chunk_118", "app_domain": "real_time", "section": "Examples — Sub-Processes", "type": "example", "domain": "sub_processes", "keywords": ["sub-process", "real-time", "entry", "read", "exit", "control"], "content": "Input: On receipt of a 5-second signal the software receives the 5-second signal, retrieves the current target temperature from the RAM, retrieves the actual sensor temperature from the Temperature Sensor, sends a Turn ON or OFF command to the Heater.\nExpected Output:\nSub-processes:\n- Sub-process: Receive 5-second signal\n  Functional User: Timer\n  Moved Data Group: 5-second signal\n  Object of Interest: Timer\n  Source: Timer\n  Destination: system\n  Type: Entry\n- Sub-process: Get Current target temperature\n  Functional User: -\n  Moved Data Group: Current target temperature\n  Object of Interest: Current settings\n  Source: Current settings (RAM)\n  Destination: system\n  Type: Read\n- Sub-process: Get Actual sensor temperature\n  Functional User: Temperature Sensor\n  Moved Data Group: Actual sensor temperature\n  Object of Interest: Temperature sensor\n  Source: Temperature Sensor\n  Destination: system\n  Type: Entry\n- Sub-process: Decide if Heater must be turned ON or OFF\n  Functional User: -\n  Moved Data Group: (None - this is data manipulation)\n  Object of Interest: -\n  Source: -\n  Destination: -\n  Type: -\n- Sub-process: Send a Turn ON or OFF command (as needed) to the Heater\n  Functional User: Heater\n  Moved Data Group: Heater On/Off command\n  Object of Interest: Heater\n  Source: system\n  Destination: Heater\n  Type: Exit"}
{"id": "chunk_019", "app_domain": "real_time", "section": "Examples — Sub-Processes", "type": "example", "domain": "sub_processes", "keywords": ["sub-process", "real-time", "entry", "exit", "actuator control"], "content": "Input: On receipt of the Start signal, the software sends Turn ON signals to both the Cooking Lamp and the Heater.\nExpected Output:\nSub-processes:\n- Sub-process: Receive Start signal\n  Functional User: Start button\n  Moved Data Group: Start signal\n  Object of Interest: Start Button\n  Source: Start button\n  Destination: system\n  Type: Entry\n- Sub-process: Send a Turn ON command to the Heater\n  Functional User: Heater\n  Moved Data Group: Heater On/Off command\n  Object of Interest: Heater\n  Source: system\n  Destination: Heater\n  Type: Exit\n- Sub-process: Send a Turn ON command to the Cooking lamp\n  Functional User: Cooking Lamp\n  Moved Data Group: Cooking lamp On/Off command\n  Object of Interest: Cooking Lamp\n  Source: system\n  Destination: Cooking Lamp\n  Type: Exit"}
{"id": "chunk_020", "app_domain": "business", "section": "Sub-Processes & Data Movements ", "type": "knowledge", "domain": "sub_processes", "keywords": ["sub-processes", "E/R/W/X", "CRUD", "responses", "COSMIC movements"], "content": "Decompose each Functional Process into COSMIC data movements (E, X, R, W).\nCommon patterns: form input (E), database read (R), database write (W), response/display/report (X).\nSequence: typically request–process–persist–respond; may include validations and authorizations."}
{"id": "chunk_021", "app_domain": "business", "section": "Examples — Sub-Processes", "type": "example", "domain": "sub_processes", "keywords": ["sub-process", "business application", "entry", "read", "write", "exit"], "content": "Input: When a Registrar wishes to enter data about a new Professor, he selects the sub-option 'Add Professor' and enters Professor details including ID, name, address, social security number, Department, qualifications and contact details.\nExpected Output:\nSub-processes:\n- Sub-process: Registrar enters Professor's details\n  Functional User: Registrar\n  Moved Data Group: Professor details\n  Object of Interest: Professor\n  Source: Registrar\n  Destination: system\n  Type: Entry\n- Sub-process: Validate and check if Professor exists\n  Functional User: N/A\n  Moved Data Group: Professor details\n  Object of Interest: Professor\n  Source: storage\n  Destination: system\n  Type: Read\n- Sub-process: Create a new Professor record\n  Functional User: N/A\n  Moved Data Group: Professor details\n  Object of Interest: Professor\n  Source: system\n  Destination: storage\n  Type: Write\n- Sub-process: Display error message\n  Functional User: Registrar\n  Moved Data Group: Error Messages\n  Object of Interest: Errors\n  Source: system\n  Destination: Registrar\n  Type: Exit"}
{"id": "chunk_0211", "app_domain":"business", "section": "Examples — Sub-Processes", "type": "example", "domain": "sub_processes","keywords":["sub-process","course offering","professor","entry","read","exit"],"content":"Input: When a Professor creates Course Offering commitments: after viewing the list of eligible Course Offerings, the Professor selects the Offerings. The system sends the selected Course Offering IDs to the Course Catalog, receives the count of conflicting Course Offerings and their IDs, then displays either the conflicts or a confirmation message.\n\nExpected Output:\nSub-processes:\n- Sub-process: Professor selects the Course Offerings\n  Functional User: Professor\n  Moved Data Group: Professor’s Course Offering selections\n  Object of Interest: Course Offering\n  Source: Professor\n  Destination: System\n  Type: Entry\n\n- Sub-process: Send selected Course Offerings to Course Catalog\n  Functional User: System\n  Moved Data Group: Professor’s Course Offering selections\n  Object of Interest: Course Offering\n  Source: System\n  Destination: Course Catalog\n  Type: Entry\n\n- Sub-process: Receive count of conflicting Course Offerings\n  Functional User: N/A\n  Moved Data Group: Count of conflicting courses\n  Object of Interest: Course Offering\n  Source: Course Catalog\n  Destination: System\n  Type: Read\n\n- Sub-process: Receive IDs of conflicting Course Offerings\n  Functional User: N/A\n  Moved Data Group: Conflicting Course Offering selections\n  Object of Interest: Course Offering\n  Source: Course Catalog\n  Destination: System\n  Type: Read\n\n- Sub-process: Display conflicts or confirmation\n  Functional User: Professor\n  Moved Data Group: Conflicting Course Offering selections\n  Object of Interest: Course Offering\n  Source: System\n  Destination: Professor\n  Type: Exit\n\n- Sub-process: Display error/confirmation message\n  Functional User: Professor\n  Moved Data Group: Error Messages\n  Object of Interest: Errors\n  Source: System\n  Destination: Professor\n  Type: Exit"}
{"id": "chunk_022", "app_domain": "general", "section": "Data Movement", "type": "definition", "domain": "data_movements", "keywords": ["movement", "triggering entry", "E/R/W/X", "boundary crossing", "COSMIC movements", "sub-processes"], "content": "General Data Movement Principle:\n- One data movement per Data Group per Functional Process, unless the FUR explicitly requires multiple occurrences.\n\nCounting Rules:\n- Entry: Count one Entry per object of interest per FP. Multiple Entries only if FUR explicitly require separate input events.\n- Exit: Count one Exit per object of interest per FP. Reports or complex outputs with multiple data groups → count each data group separately.\n- Read: Count one Read per data group per FP. Repeated reads of same data group within one process → count once.\n- Write: Count one Write per data group per FP. Creation, update, and deletion of same data group → each counts as one Write.\n\nSpecial Cases:\n- Error or confirmation messages: one Exit covers all standard confirmations; if output contains distinct business data, count a separate Exit.\n- Validation: if data retrieval is required for validation, count a Read separately from the Entry.\n- Batch or aggregated operations: count by distinct data groups affected.\n- Exclude control commands and display-only labels — they are not data movements.\n\nThese rules complement the COSMIC data movement definitions and ensure consistent CFP counting across all sub-process decompositions."}
{"id": "chunk_023", "app_domain": "general", "section": "Multiple Occurrence Rules", "type": "rules", "domain": "data_movements", "keywords": ["multiple occurrences", "occurrence counting", "data values", "single movement"], "content": "Multiple Occurrence Rules in COSMIC measurement. Core Rule: Multiple occurrences of different data values = single data movement count. Application: Different data values for same data group count as one movement, quantity of data doesn't affect movement count, batch processing of same data group = single movement. Examples: Processing 100 orders = single data movement (if same data group structure), reading customer list with 500 customers = single Read movement, generating reports for multiple periods = count by distinct data group types. Validation: Verify data group consistency across occurrences, ensure same object of interest across occurrences, document occurrence handling approach."}
{"id": "chunk_024", "app_domain": "general", "section": "Error Message Handling Rules", "type": "rules", "domain": "data_movements", "keywords": ["error messages", "confirmation messages", "message handling", "exit rules"], "content": "Error Message Handling Rules in COSMIC measurement. General Rule: One Exit movement accounts for all error/confirmation message types from one functional process. Detailed Rules: If message provides only confirmation/error indication = single Exit for all message types, if message provides additional data beyond error/confirmation = separate Exit movement, error handling logic included in movement processing. Message Categories: Simple confirmations (OK, Error), informational messages, data-carrying error messages, system status messages. Counting Approach: Analyze message content, determine if additional data provided, count distinct data groups in messages, avoid over-counting message variations."}
{"id": "chunk_025", "app_domain": "general", "section": "Validation Checkpoints", "type": "validation", "domain": "quality_assurance", "keywords": ["validation", "quality assurance", "checkpoints", "measurement verification"], "content": "Mandatory Validations: All functional processes have triggering Entry, each data movement moves exactly one data group, all functional users are identified and documented, minimum two data movements per functional process. Quality Assurance Practices: Maintain consistent level of granularity across functional processes, clearly define software boundaries before measurement, properly identify all functional users including humans, other software, and hardware devices, maintain detailed documentation for measurement reproducibility, validate measurements against FUR completeness and accuracy."}
{"id": "chunk_026", "app_domain": "general", "section": "Common Errors Prevention", "type": "validation", "domain": "quality_assurance", "keywords": ["common mistakes", "error prevention", "measurement errors", "prevention rules"], "content": "Common Mistakes: 1) Boundary Confusion (mixing software layers in single measurement scope), 2) User Misidentification (failing to identify all functional users), 3) Movement Overcounting (counting multiple occurrences as separate movements), 4) Granularity Inconsistency (mixing different levels of functional process granularity), 5) FUR Incompleteness (measuring based on incomplete or unclear requirements). Prevention Rules: Define FSM purpose and scope before measurement, maintain consistent granularity level, document all functional users, validate against FUR completeness, follow standard measurement patterns."}
{"id": "chunk_027", "app_domain": "general", "section": "Quality & Validation – Common Errors", "type": "quality_assurance", "domain": "quality_assurance", "keywords": ["validation", "common mistakes", "CFP quality"], "content": "Common issues to flag:\n- A step moves more than ONE Data Group.\n- User asks an operation that saves or updates data but no user feedback is emitted (missing Exit).\n- Internal processing counted as System→System movement.\n- Triggering event split across multiple processes without justification.\n- Data Group mixes unrelated attributes."}
